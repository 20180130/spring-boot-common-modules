# Sorting Algorithm
## 描述
排序算法描述，具体有以下几种排序算法
* 冒泡排序
* 选择排序
* 插入排序
* 归并排序
* 希尔排序
* 堆排序
* 快速排序
* 基数排序
* 对象排序
## 思路解析
### 冒泡排序
冒泡排序可以从小到大排序，也可以从大到小排序，以从小到大排序例子描述如下：  
进行N趟排序，每趟循环从索引0处开始比较相邻数据，若前一个大于后一个数则交换。每趟选择一个最大放入最右边。直至排序成功。  
示例：  
* arr原始数据: 934 687 63 705 639 475 42 824 776 824
* 第0趟排序为: 687 63 705 639 475 42 824 776 824 934
* 第1趟排序为: 63 687 639 475 42 705 776 824 824 934
* 第2趟排序为: 63 639 475 42 687 705 776 824 824 934
* 第3趟排序为: 63 475 42 639 687 705 776 824 824 934
* 第4趟排序为: 63 42 475 639 687 705 776 824 824 934
* 第5趟排序为: 42 63 475 639 687 705 776 824 824 934
* 第6趟排序为: 42 63 475 639 687 705 776 824 824 934
* 第7趟排序为: 42 63 475 639 687 705 776 824 824 934
* 第8趟排序为: 42 63 475 639 687 705 776 824 824 934
* 第9趟排序为: 42 63 475 639 687 705 776 824 824 934
#### 冒泡排序效率分析
一般来说，数组中有N个数据项，则第一趟排序中有N-1次比较，第二趟中有N-2次，如此类推。这种序列的求和公式如下：`(N-1)+(N-2)+(N-3)+...+1= N(N-1)/2`   
数据若随机,那么大概有一半数据需要交换，则交换的次数为N^2/4,最坏的情况下，即初始数据逆序时，每次比较都需要交换，次数为N^2/2。  
大O表示法：即认为冒泡排序需要O(N^2)时间级别。
### 选择排序
把数据进行扫描，从中挑出最小的一个数字，最小的数字和未排序的最左端的数字交换位置。进行N趟即可。  
示例：  
* arr原始数据: 260 585 713 921 343 735 798 470 505 53
* 第0趟排序为: 53 585 713 921 343 735 798 470 505 260
* 第1趟排序为: 53 260 713 921 343 735 798 470 505 585
* 第2趟排序为: 53 260 343 921 713 735 798 470 505 585
* 第3趟排序为: 53 260 343 470 713 735 798 921 505 585
* 第4趟排序为: 53 260 343 470 505 735 798 921 713 585
* 第5趟排序为: 53 260 343 470 505 585 798 921 713 735
* 第6趟排序为: 53 260 343 470 505 585 713 921 798 735
* 第7趟排序为: 53 260 343 470 505 585 713 735 798 921
* 第8趟排序为: 53 260 343 470 505 585 713 735 798 921
* 第9趟排序为: 53 260 343 470 505 585 713 735 798 921
#### 选择排序效率分析
一般来说，数组中有N个数据项，则第一趟排序中有N-1次比较，第二趟中有N-2次，如此类推。这种序列的求和公式如下(和冒泡排序结果一样)：`(N-1)+(N-2)+(N-3)+...+1= N(N-1)/2`。  
选择排序每一趟排序进行一次交换数据，因此其选择排序交换次数为O(n)  
特点：交换次数少
### 插入排序
思路如下。
1. 选择两个初始数字。
2. 每趟排序有序的插入一个数字，可以从已经排序的数组最后面开始移动，后满足条件将数据插入。
示例：
* arr原始数据: 919 38 951 272 962 720 250 443 719 80
* 第1趟排序为: 38 919 951 272 962 720 250 443 719 80
* 第2趟排序为: 38 919 951 272 962 720 250 443 719 80
* 第3趟排序为: 38 272 919 951 962 720 250 443 719 80
* 第4趟排序为: 38 272 919 951 962 720 250 443 719 80
* 第5趟排序为: 38 272 720 919 951 962 250 443 719 80
* 第6趟排序为: 38 250 272 720 919 951 962 443 719 80
* 第7趟排序为: 38 250 272 443 720 919 951 962 719 80
* 第8趟排序为: 38 250 272 443 719 720 919 951 962 80
* 第9趟排序为: 38 80 250 272 443 719 720 919 951 962
#### 插入排序效率分析
算法需要多少次比较和复制呢？在第一趟排序中，它最多比较一次，第二趟最多比较两次，以此类推。`1+2+3+...+N-1 = N*(N-1)/2`   
然而，因为在每一趟排序发现插入点之前，平均只有全体数据项的一半真的进行了比较，我们除以2得到N*(N-1)/4  
注意:插入排序若遍历时满足条件，则当前元素插入，后面未遍历的数据不再遍历，因此有平均一说。  
复制的次数大致等于比较的次数。然而，一次复制与一次交换的时间耗费不同，所以相对于随机数据，这个算法比冒泡排序快一倍，比选择排序略快。    
特点：复制次数多,N*(N-1)/4
### 归并排序
实现的一个思路如下，还有其它的实现思路。   
将数组分为两边,对左边排序,对右边排序,将左右两边合并排序。  
示例：
* arr原始数据: 431 144 522 94 564 242 587 228 853 741 
* merge(low 0,mid 0,high 1)144 431 522 94 564 242 587 228 853 741 
* merge(low 0,mid 1,high 2)144 431 522 94 564 242 587 228 853 741 
* merge(low 3,mid 3,high 4)144 431 522 94 564 242 587 228 853 741 
* merge(low 0,mid 2,high 4)94 144 431 522 564 242 587 228 853 741 
* merge(low 5,mid 5,high 6)94 144 431 522 564 242 587 228 853 741 
* merge(low 5,mid 6,high 7)94 144 431 522 564 228 242 587 853 741 
* merge(low 8,mid 8,high 9)94 144 431 522 564 228 242 587 741 853 
* merge(low 5,mid 7,high 9)94 144 431 522 564 228 242 587 741 853 
* merge(low 0,mid 4,high 9)94 144 228 242 431 522 564 587 741 853 
#### 归并排序效率分析
略微复杂，主要特点是：消耗内存多，需要将数据复制至新数组，再将其复制至原数组。时间复杂度为：`O(N*logN)`
### 希尔排序
思路如下。  
1. 首先以(n=数组长度/2)为增量，分为n组。
2. 对每组数据进行插入排序。
示例：
* arr原始数据: 710 738 172 721 276 754 884 756 868 324 
* 增量为5的排序结果: 710 738 172 721 276 754 884 756 868 324  
  解析：序号0与5,10(如果10元素存在)元素进行排序，即710和754，再1与6,2与7.3与8
* 增量为2的排序结果: 172 324 276 721 710 738 868 754 884 756 
* 增量为1的排序结果: 172 276 324 710 721 738 754 756 868 884 
#### 希尔排序效率分析
时间复杂度分析：希尔排序的时间复杂度估计为`O(N^3/2)到O(N^7/6)`。
### 堆排序
思路如下。  
1. 构建元素为n的大顶堆，即将数组看成是完全二叉树格式，从第1个非叶子节点开始查找元素，找到二叉树的根元素。
2. 将根元素与末尾数字交换。再构造元素为n-1的大顶堆，再交换数组，直至完成。
示例：
* arr原始数据: 11 80 3 77 22 4 75 93 60 82 
* 创建10大顶堆: 22 11 75 80 82 4 3 77 60 93 
* 创建9大顶堆: 60 22 75 80 11 4 3 77 82 93 
* 创建8大顶堆: 77 60 75 22 11 4 3 80 82 93 
* 创建7大顶堆: 3 60 75 22 11 4 77 80 82 93 
* 创建6大顶堆: 4 60 3 22 11 75 77 80 82 93 
* 创建5大顶堆: 11 4 3 22 60 75 77 80 82 93 
* 创建4大顶堆: 4 11 3 22 60 75 77 80 82 93 
* 创建3大顶堆: 3 4 11 22 60 75 77 80 82 93 
* 创建2大顶堆: 3 4 11 22 60 75 77 80 82 93
#### 堆排序效率分析
堆排序运行的时间复杂度为O(N*logN)。  
与快速排序的比较:它比快速排序略慢，但它比快速排序优越的一点是它对初始数据的分布不敏感。在关键字值按某种排列顺序的情况下，快速排序运行的时间复杂度可以降到`O(N^2)`级,然而堆排序对任意排列的数据，其排序的时间复杂度都是`O(N*logN)`.
### 快速排序
思路如下。 
1. 先从数列中取出一个数作为基准数。
2. 分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。
3. 再对左右区间重复第二步，直到各区间只有一个数。
示例：
* arr原始数据: 49 612 274 507 73 865 364 504 732 156 
* begin  key: 49-low: 0-high: 9  
    end  :49 612 274 507 73 865 364 504 732 156 
* begin  key: 612-low: 1-high: 9  
    end  :49 156 274 507 73 504 364 612 732 865 
* begin  key: 156-low: 1-high: 6  
    end  :49 73 156 507 274 504 364 612 732 865 
* begin  key: 507-low: 3-high: 6  
    end  :49 73 156 364 274 504 507 612 732 865 
* begin  key: 364-low: 3-high: 5  
    end  :49 73 156 274 364 504 507 612 732 865 
* begin  key: 732-low: 8-high: 9  
    end  :49 73 156 274 364 504 507 612 732 865 
#### 快速排序效率分析
快速排序的时间复杂度为`O(n*logN)`。如归并排序一样，对分治算法总的来说都是这样的，在分治算法中用递归的方法把一列数据项分为两组，然后调用自身来分别处理每一组数据项。这种情况下，算法实际上是以2为底的：运行时间和N*log2^N成正比。
### 基数排序
### 对象排序
实现对象的比较器接口，重写对象的比较方法，如compareTo，实现指定的对象排序规则。
## 各种排序查询的算法效率比较
